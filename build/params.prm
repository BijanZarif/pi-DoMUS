# Listing of Parameters
# ---------------------
subsection Cube
  # First additional Point<spacedim> to be used in the generation of the grid.
  # The use of it will depend on the specific grid.
  set First additional Point<spacedim> input for the grid  = 0,0

  # First additional double to be used in the generation of the grid. The use
  # of it will depend on the specific grid.
  set First additional double input for the grid           = 1.

  # The grid to generate. You can choose among
  # file: read grid from a file (use Input grid filename for the filename)
  # unit_hypercube: create a unit hypercube
  # unit_hypershell: create a unit hypersphere
  # hypercube: create a unit hypercube using the additional input
  set Grid to generate                                     = unit_hypercube

  # Name of the input grid. All supported deal.II formats. The extestion will
  # be used to decide what grid format to use.
  set Input grid file name                                 = 
  set Mesh smoothing alogrithm                             = none

  # Name of the output grid. All supported deal.II formats. The extestion will
  # be used to decide what grid format to use. If empty, no grid will be
  # written.
  set Output grid file name                                = 

  # Second additional Point<spacedim> to be used in the generation of the
  # grid. The use of it will depend on the specific grid.
  set Second additional Point<spacedim> input for the grid = 0,0

  # Second additional double to be used in the generation of the grid. The use
  # of it will depend on the specific grid.
  set Second additional double input for the grid          = 0.5

  # Unsigned int to be used in the generation of the grid. The use of it will
  # depend on the specific grid.
  set Unsigned int input for the grid                      = 1
end


subsection Dirichlet boundary conditions
  # Sometimes it is convenient to use symbolic constants in the expression
  # that describes the function, rather than having to use its numeric value
  # everywhere the constant appears. These values can be defined using this
  # parameter, in the form `var1=value1, var2=value2, ...'.
  # 
  # A typical example would be to set this runtime parameter to
  # `pi=3.1415926536' and then use `pi' in the expression of the actual
  # formula. (That said, for convenience this class actually defines both `pi'
  # and `Pi' by default, but you get the idea.)
  set Function constants  = 

  # The formula that denotes the function you want to evaluate for particular
  # values of the independent variables. This expression may contain any of
  # the usual operations such as addition or multiplication, as well as all of
  # the common functions such as `sin' or `cos'. In addition, it may contain
  # expressions like `if(x>0, 1, -1)' where the expression evaluates to the
  # second argument if the first argument is true, and to the third argument
  # otherwise. For a full overview of possible expressions accepted see the
  # documentation of the muparser library at http://muparser.beltoforion.de/.
  # 
  # If the function you are describing represents a vector-valued function
  # with multiple components, then separate the expressions for individual
  # components by a semicolon.
  set Function expression = if(y>.99, 1, 0); 0; 0

  # The name of the variables as they will be used in the function, separated
  # by commas. By default, the names of variables at which the function will
  # be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial
  # coordinates and `t' for time. You can then use these variable names in
  # your function expression and they will be replaced by the values of these
  # variables at which the function is currently evaluated. However, you can
  # also choose a different set of names for the independent variables at
  # which to evaluate your function expression. For example, if you work in
  # spherical coordinates, you may wish to set this input parameter to
  # `r,phi,theta,t' and then use these variable names in your function
  # expression.
  set Variable names      = x,y,t
end


subsection FE_Q
  # The finite element space to use. For vector finite elements use the
  # notation FESystem[FE_Q(2)^2-FE_DGP(1)] (e.g. Navier-Stokes).
  set Finite element space = FESystem[FE_Q(2)^dim-FE_Q(1)]
end


