# Listing of Parameters
# ---------------------
subsection Cube
  # First additional Point<spacedim> to be used in the generation of the grid.
  # The use of it will depend on the specific grid.
  set First additional Point<spacedim> input for the grid  = 0,0

  # First additional double to be used in the generation of the grid. The use
  # of it will depend on the specific grid.
  set First additional double input for the grid           = 1.

  # The grid to generate. You can choose among
  # file: read grid from a file (use Input grid filename for the filename)
  # unit_hypercube: create a unit hypercube
  # unit_hypershell: create a unit hypersphere
  # hypercube: create a unit hypercube using the additional input
  set Grid to generate                                     = unit_hypercube

  # Name of the input grid. All supported deal.II formats. The extestion will
  # be used to decide what grid format to use.
  set Input grid file name                                 = 
  set Mesh smoothing alogrithm                             = none

  # Name of the output grid. All supported deal.II formats. The extestion will
  # be used to decide what grid format to use. If empty, no grid will be
  # written.
  set Output grid file name                                = 

  # Second additional Point<spacedim> to be used in the generation of the
  # grid. The use of it will depend on the specific grid.
  set Second additional Point<spacedim> input for the grid = 0,0

  # Second additional double to be used in the generation of the grid. The use
  # of it will depend on the specific grid.
  set Second additional double input for the grid          = 0.5

  # Unsigned int to be used in the generation of the grid. The use of it will
  # depend on the specific grid.
  set Unsigned int input for the grid                      = 1
end


subsection Dirichlet boundary conditions
  # Sometimes it is convenient to use symbolic constants in the expression
  # that describes the function, rather than having to use its numeric value
  # everywhere the constant appears. These values can be defined using this
  # parameter, in the form `var1=value1, var2=value2, ...'.
  # 
  # A typical example would be to set this runtime parameter to
  # `pi=3.1415926536' and then use `pi' in the expression of the actual
  # formula. (That said, for convenience this class actually defines both `pi'
  # and `Pi' by default, but you get the idea.)
  set Function constants  = k=1

  # The formula that denotes the function you want to evaluate for particular
  # values of the independent variables. This expression may contain any of
  # the usual operations such as addition or multiplication, as well as all of
  # the common functions such as `sin' or `cos'. In addition, it may contain
  # expressions like `if(x>0, 1, -1)' where the expression evaluates to the
  # second argument if the first argument is true, and to the third argument
  # otherwise. For a full overview of possible expressions accepted see the
  # documentation of the muparser library at http://muparser.beltoforion.de/.
  # 
  # If the function you are describing represents a vector-valued function
  # with multiple components, then separate the expressions for individual
  # components by a semicolon.
  set Function expression = k*pi*cos(k*pi*x)*cos(k*pi*y); k*pi*sin(k*pi*x)*sin(k*pi*y); 0

  # The name of the variables as they will be used in the function, separated
  # by commas. By default, the names of variables at which the function will
  # be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial
  # coordinates and `t' for time. You can then use these variable names in
  # your function expression and they will be replaced by the values of these
  # variables at which the function is currently evaluated. However, you can
  # also choose a different set of names for the independent variables at
  # which to evaluate your function expression. For example, if you work in
  # spherical coordinates, you may wish to set this input parameter to
  # `r,phi,theta,t' and then use these variable names in your function
  # expression.
  set Variable names      = x,y,t
end


subsection ErrorHandler<2>
  set Compute error            = true
  set Error file format        = tex
  set Output error tables      = true
  # Comma separated list of names for the components. This will be used both
  # for error tables in text format and to output the solution to a file. Note
  # that in the case of a vector function the error name which is used to
  # compute the norm (supposing the type of the other components is 'Add') is
  # the first one.
  set Solution names           = u

  # Comma separated version of the same thing as above for the latex version
  # of the table.
  set Solution names for latex = u

  # Comma separated list of table names.
  set Table names              = error
  set Write error files        = false


  subsection Table 0
    # Evaluate convergence rates and add a column to the table for each
    # computed norm.
    set Add convergence rates          = true

    # The extra columns to add to the table.
    set Extra terms                    = cells,dofs

    # The caption that will go under the table if we write the file in tex
    # format. The default value for this object is the same name as the table
    # name.
    set Latex table caption            = error

    # Each component is separated by a semicolon, and each norm by a comma.
    # Implemented norms are Linfty, L2, H1 and AddUp, which means that the
    # norm is added to the previous component. Useful for vector valued
    # functions.
    set List of error norms to compute = Linfty, L2, H1

    # The key to use to compute the convergence rates.
    set Rate key                       = 
  end

  subsection Table 1
    # Evaluate convergence rates and add a column to the table for each
    # computed norm.
    set Add convergence rates          = true

    # The extra columns to add to the table.
    set Extra terms                    = cells,dofs

    # The caption that will go under the table if we write the file in tex
    # format. The default value for this object is the same name as the table
    # name.
    set Latex table caption            = error

    # Each component is separated by a semicolon, and each norm by a comma.
    # Implemented norms are Linfty, L2, H1 and AddUp, which means that the
    # norm is added to the previous component. Useful for vector valued
    # functions.
    set List of error norms to compute = Linfty, L2, H1

    # The key to use to compute the convergence rates.
    set Rate key                       = 
  end

end


subsection FE_Q
  # The finite element space to use. For vector finite elements use the
  # notation FESystem[FE_Q(2)^2-FE_DGP(1)] (e.g. Navier-Stokes).
  set Finite element space = FESystem[FE_Q(2)^dim-FE_Q(1)]
end

subsection Right-hand side force
  # Sometimes it is convenient to use symbolic constants in the expression
  # that describes the function, rather than having to use its numeric value
  # everywhere the constant appears. These values can be defined using this
  # parameter, in the form `var1=value1, var2=value2, ...'.
  # 
  # A typical example would be to set this runtime parameter to
  # `pi=3.1415926536' and then use `pi' in the expression of the actual
  # formula. (That said, for convenience this class actually defines both `pi'
  # and `Pi' by default, but you get the idea.)
  set Function constants  = k=1

  # The formula that denotes the function you want to evaluate for particular
  # values of the independent variables. This expression may contain any of
  # the usual operations such as addition or multiplication, as well as all of
  # the common functions such as `sin' or `cos'. In addition, it may contain
  # expressions like `if(x>0, 1, -1)' where the expression evaluates to the
  # second argument if the first argument is true, and to the third argument
  # otherwise. For a full overview of possible expressions accepted see the
  # documentation of the muparser library at http://muparser.beltoforion.de/.
  # 
  # If the function you are describing represents a vector-valued function
  # with multiple components, then separate the expressions for individual
  # components by a semicolon.
  set Function expression = 2*k^3*pi^3*cos(k*pi*x)*cos(k*pi*y); 2*k^3*pi^3*sin(k*pi*x)*sin(k*pi*y); 0

  # The name of the variables as they will be used in the function, separated
  # by commas. By default, the names of variables at which the function will
  # be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in 3d) for spatial
  # coordinates and `t' for time. You can then use these variable names in
  # your function expression and they will be replaced by the values of these
  # variables at which the function is currently evaluated. However, you can
  # also choose a different set of names for the independent variables at
  # which to evaluate your function expression. For example, if you work in
  # spherical coordinates, you may wish to set this input parameter to
  # `r,phi,theta,t' and then use these variable names in your function
  # expression.
  set Variable names      = x,y,t
end


